{"version":3,"sources":["../../src/forms/formGroupAsyncSpec.js"],"names":["describe","mockForm","beforeEach","formName","groups","formGroupAsync","it","expect","toBe","toBeArrayOfStrings","resolve","toBeFunction","reject","getName","getNames","resolvers","toHaveMember","rejecters","resolvedMemo","toBeEmptyObject","bind","toThrowError","spyObj","fn","n","spyOn","each","toHaveBeenCalled","resolvedAsync","successCallbacks","toBeEmptyArray","failCallbacks","mockPersonalDetails","firstName","groupName","toBeObject","undefined","toBeNull","done","mockDeliveryDetails","line1","then","formData","fail","err","resolvedGroup","generatePromises","rejectedAsync"],"mappings":"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","file":"formGroupAsyncSpec.js","sourcesContent":["import FormGroupAsync from './formGroupAsync';\n\ndescribe('FormGroupAsync', () => {\n  describe(\n    `Use this if you have multiple form groups\n    AND you want to submit the form only WHEN all groups are valid`\n    , () => {\n      let mockForm;\n      beforeEach(() => {\n        mockForm = {\n          formName: 'addressForm',\n          groups: ['personal', 'address']\n        };\n      });\n\n      let formGroupAsync;\n      beforeEach(() => {\n        formGroupAsync = new FormGroupAsync(mockForm);\n      });\n\n      describe('initialise', () => {\n        it('SHOULD assign init props correctly', () => {\n          expect(formGroupAsync.formName).toBe(mockForm.formName);\n          expect(formGroupAsync.groups).toBeArrayOfStrings();\n        });\n\n        it(`SHOULD init all the necessary public methods\n        (resolve, reject, getName, getNames, each, success, fail)\n        `, () => {\n            expect(formGroupAsync.resolve).toBeFunction();\n            expect(formGroupAsync.reject).toBeFunction();\n            expect(formGroupAsync.getName).toBeFunction();\n            expect(formGroupAsync.getNames).toBeFunction();\n          });\n\n        it('SHOULD generate all the resolve callbacks with the correct names', () => {\n          expect(formGroupAsync.resolvers)\n            .toHaveMember(`${mockForm.formName}-${mockForm.groups[0]}`);\n          expect(formGroupAsync.resolvers)\n            .toHaveMember(`${mockForm.formName}-${mockForm.groups[1]}`);\n        });\n\n        it('SHOULD generate all the reject callbacks with the correct names', () => {\n          expect(formGroupAsync.rejecters)\n            .toHaveMember(`${mockForm.formName}-${mockForm.groups[0]}`);\n          expect(formGroupAsync.rejecters)\n            .toHaveMember(`${mockForm.formName}-${mockForm.groups[1]}`);\n        });\n\n        it('SHOULD generate a memo for resolved promises', () => {\n          expect(formGroupAsync.resolvedMemo).toBeEmptyObject();\n        });\n      });\n\n      describe('Utility methods', () => {\n        describe('getName - returns the name-spaced group name', () => {\n          it('SHOULD return the \"form name\" + \"group name\" as a concatenated string', () => {\n            expect(formGroupAsync.getName(mockForm.groups[0]))\n              .toBe(`${mockForm.formName}-${mockForm.groups[0]}`);\n          });\n\n          it('SHOULD throw an error if group name is not found', () => {\n            expect(formGroupAsync.getName.bind(formGroupAsync, 'dummyGroup')).toThrowError();\n          });\n        });\n\n        describe('getNames - returns an array of name-spaced group names', () => {\n          it('SHOULD return an array of group name (\"form name\" + \"group name\")', () => {\n            expect(formGroupAsync.getNames()).toBeArrayOfStrings();\n          });\n        });\n\n        describe('each - iterates through each group and executes the given callback method', () => {\n          it('SHOULD execute the given callback method', () => {\n            const spyObj = { fn: n => n };\n            spyOn(spyObj, 'fn');\n            formGroupAsync.each(spyObj.fn);\n            expect(spyObj.fn).toHaveBeenCalled();\n          });\n        });\n      });\n\n      describe('Handling promises', () => {\n        it('SHOULD create an empty array to contain success/fail callback methods', () => {\n          const resolvedAsync = new FormGroupAsync({\n            formName: 'addressForm',\n            groups: ['personal', 'address']\n          });\n\n          expect(resolvedAsync.successCallbacks).toBeEmptyArray();\n          expect(resolvedAsync.failCallbacks).toBeEmptyArray();\n        });\n\n        describe('WHEN a group is resolved', () => {\n          it('SHOULD store the resolved data in a memo', () => {\n            const mockPersonalDetails = { firstName: 'John' };\n            const resolvedAsync = new FormGroupAsync({\n              formName: 'addressForm',\n              groups: ['personal', 'address']\n            });\n            const groupName = resolvedAsync.getName(mockForm.groups[0]);\n\n            resolvedAsync.resolve(\n              mockPersonalDetails,\n              groupName\n            );\n\n            expect(resolvedAsync.resolvedMemo[groupName]).toBeObject();\n          });\n\n          describe('AND resolved again', () => {\n            it('SHOULD store the latest resolved data in the memo', () => {\n              const resolvedAsync = new FormGroupAsync({\n                formName: 'addressForm',\n                groups: ['personal', 'address']\n              });\n              const groupName = resolvedAsync.getName(mockForm.groups[0]);\n\n              // since we cannot call the done method after a private promise is resolved\n              // assume the promise is resolved\n              resolvedAsync.resolvers[groupName] = undefined;\n              resolvedAsync.resolve(\n                { firstName: 'Ben' },\n                groupName\n              );\n              expect(resolvedAsync.resolvedMemo[groupName].firstName).toBe('Ben');\n            });\n          });\n\n          describe('AND rejected', () => {\n            it('SHOULD remove the resolved data from the memo', () => {\n              const resolvedAsync = new FormGroupAsync({\n                formName: 'addressForm',\n                groups: ['personal', 'address']\n              });\n              const groupName = resolvedAsync.getName(mockForm.groups[0]);\n\n              // since we cannot call the done method after a private promise is resolved\n              // assume the promise is resolved\n              resolvedAsync.rejecters[groupName] = undefined;\n              resolvedAsync.reject(\n                ['error msg'],\n                groupName\n              );\n              expect(resolvedAsync.resolvedMemo[groupName]).toBeNull();\n            });\n          });\n\n          describe('AND all groups are resolved', () => {\n            it('SHOULD call success method with correct data', (done) => {\n              const mockPersonalDetails = { firstName: 'John' };\n              const mockDeliveryDetails = { line1: '123 Downing St.' };\n              const resolvedAsync = new FormGroupAsync({\n                formName: 'addressForm',\n                groups: ['personal', 'address']\n              });\n\n              resolvedAsync.resolve(\n                mockPersonalDetails,\n                resolvedAsync.getName(mockForm.groups[0])\n              );\n              resolvedAsync.resolve(\n                mockDeliveryDetails,\n                resolvedAsync.getName(mockForm.groups[1])\n              );\n\n              resolvedAsync.then((formData) => {\n                expect(formData.firstName).toBe(mockPersonalDetails.firstName);\n                expect(formData.line1).toBe(mockDeliveryDetails.line1);\n                done();\n              }).fail(err => done.fail(`Error handler is called WHEN not intended | ${err}`));\n            });\n          });\n\n          describe('AND another group is rejected', () => {\n            let resolvedAsync;\n            let resolvedGroup;\n            beforeEach(() => {\n              const mockPersonalDetails = { firstName: 'John' };\n              resolvedAsync = new FormGroupAsync({\n                formName: 'addressForm',\n                groups: ['personal', 'address']\n              });\n              const groupName = resolvedAsync.getName(mockForm.groups[1]);\n              resolvedAsync.rejecters[groupName] = () => null;\n\n              resolvedGroup = resolvedAsync.getName(mockForm.groups[0]);\n              resolvedAsync.resolve(\n                mockPersonalDetails,\n                resolvedGroup\n              );\n              resolvedAsync.reject(\n                ['error msg'],\n                resolvedAsync.getName(mockForm.groups[1])\n              ).fail(() => null);\n            });\n\n            it('SHOULD remember the resolved promise', () => {\n            // since we cannot call the done method after catch\n            // assume the above beforeEach happened and the last THEN statement\n            // is executed\n              resolvedAsync.generatePromises();\n\n              expect(resolvedAsync.resolvedMemo[resolvedGroup]).toHaveMember('firstName');\n            });\n          });\n        });\n\n        describe('WHEN a group is rejected', () => {\n          it('SHOULD remove the group from the resolved memo', (done) => {\n            const rejectedAsync = new FormGroupAsync({\n              formName: 'addressForm',\n              groups: ['personal', 'address']\n            });\n            const groupName = rejectedAsync.getName(mockForm.groups[0]);\n\n            rejectedAsync.reject(\n              ['error message'],\n              groupName\n            );\n\n            rejectedAsync.fail((err) => {\n              expect(err).toBeArrayOfStrings();\n              expect(rejectedAsync.resolvedMemo[groupName]).toBeNull();\n              done();\n            });\n          });\n\n          it('SHOULD call error method', (done) => {\n            const rejectedAsync = new FormGroupAsync({\n              formName: 'addressForm',\n              groups: ['personal', 'address']\n            });\n\n            rejectedAsync.reject(\n              ['error message'],\n              rejectedAsync.getName(mockForm.groups[0])\n            );\n\n            rejectedAsync\n              .then(() => {\n                done.fail('Success handler is called WHEN not intended!');\n              })\n              .fail((err) => {\n                expect(err).toBeArrayOfStrings();\n                done();\n              });\n          });\n        });\n      });\n    }\n  );\n});\n"]}