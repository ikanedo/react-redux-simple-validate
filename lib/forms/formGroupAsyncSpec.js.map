{"version":3,"sources":["../../src/forms/formGroupAsyncSpec.js"],"names":["describe","mockForm","beforeEach","formName","groups","formGroupAsync","FormGroupAsync","it","expect","toBe","toBeArrayOfStrings","resolve","toBeFunction","reject","getName","getNames","resolvers","toHaveMember","rejecters","resolvedMemo","toBeEmptyObject","bind","toThrowError","spyObj","fn","n","spyOn","each","toHaveBeenCalled","toEqual","jasmine","arrayContaining","setGroups","not","toThrowAnyError","addGroup","removeGroup","done","mockPersonalDetails","firstName","mockDeliveryDetails","line1","resolvedAsync","then","formData","fail","err","rejectedAsync","groupName","toBeNull","successCallbacks","toBeEmptyArray","failCallbacks","toBeObject","undefined","resolvedGroup","generatePromises"],"mappings":"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","file":"formGroupAsyncSpec.js","sourcesContent":["import FormGroupAsync from './formGroupAsync';\n\ndescribe('FormGroupAsync', () => {\n  describe(\n    `Use this if you have multiple form groups\n    AND you want to submit the form only WHEN all groups are valid`\n    , () => {\n      let mockForm;\n      beforeEach(() => {\n        mockForm = {\n          formName: 'addressForm',\n          groups: ['personal', 'address']\n        };\n      });\n\n      let formGroupAsync;\n      beforeEach(() => {\n        formGroupAsync = new FormGroupAsync(mockForm);\n      });\n\n      describe('initialise', () => {\n        it('SHOULD assign init props correctly', () => {\n          expect(formGroupAsync.formName).toBe(mockForm.formName);\n          expect(formGroupAsync.groups).toBeArrayOfStrings();\n        });\n\n        it(`SHOULD init all the necessary public methods\n        (resolve, reject, getName, getNames, each, success, fail)\n        `, () => {\n            expect(formGroupAsync.resolve).toBeFunction();\n            expect(formGroupAsync.reject).toBeFunction();\n            expect(formGroupAsync.getName).toBeFunction();\n            expect(formGroupAsync.getNames).toBeFunction();\n          });\n\n        it('SHOULD generate all the resolve callbacks with the correct names', () => {\n          expect(formGroupAsync.resolvers)\n            .toHaveMember(`${mockForm.formName}-${mockForm.groups[0]}`);\n          expect(formGroupAsync.resolvers)\n            .toHaveMember(`${mockForm.formName}-${mockForm.groups[1]}`);\n        });\n\n        it('SHOULD generate all the reject callbacks with the correct names', () => {\n          expect(formGroupAsync.rejecters)\n            .toHaveMember(`${mockForm.formName}-${mockForm.groups[0]}`);\n          expect(formGroupAsync.rejecters)\n            .toHaveMember(`${mockForm.formName}-${mockForm.groups[1]}`);\n        });\n\n        it('SHOULD generate a memo for resolved promises', () => {\n          expect(formGroupAsync.resolvedMemo).toBeEmptyObject();\n        });\n      });\n\n      describe('Utility methods', () => {\n        describe('getName - returns the name-spaced group name', () => {\n          it('SHOULD return the \"form name\" + \"group name\" as a concatenated string', () => {\n            expect(formGroupAsync.getName(mockForm.groups[0]))\n              .toBe(`${mockForm.formName}-${mockForm.groups[0]}`);\n          });\n\n          it('SHOULD throw an error if group name is not found', () => {\n            expect(formGroupAsync.getName.bind(formGroupAsync, 'dummyGroup')).toThrowError();\n          });\n        });\n\n        describe('getNames - returns an array of name-spaced group names', () => {\n          it('SHOULD return an array of group name (\"form name\" + \"group name\")', () => {\n            expect(formGroupAsync.getNames()).toBeArrayOfStrings();\n          });\n        });\n\n        describe('each - iterates through each group and executes the given callback method', () => {\n          it('SHOULD execute the given callback method', () => {\n            const spyObj = { fn: n => n };\n            spyOn(spyObj, 'fn');\n            formGroupAsync.each(spyObj.fn);\n            expect(spyObj.fn).toHaveBeenCalled();\n          });\n        });\n\n        describe('setGroups', () => {\n          it('SHOULD set formGroups promises', () => {\n            expect(formGroupAsync.groups).toEqual(jasmine.arrayContaining(['personal', 'address']));\n            formGroupAsync.setGroups(['personal']);\n            expect(formGroupAsync.groups).toEqual(jasmine.arrayContaining(['personal']));\n            expect(formGroupAsync.groups).not.toEqual(jasmine.arrayContaining(['personal', 'address']));\n          });\n\n          it('SHOULD throw an error if not string', () => {\n            expect(formGroupAsync.setGroups.bind(formGroupAsync, 'newGroup')).toThrowAnyError();\n          });\n        });\n\n        describe('addGroup', () => {\n          it('SHOULD add formGroup name', () => {\n            expect(formGroupAsync.groups).toEqual(jasmine.arrayContaining(['personal', 'address']));\n            formGroupAsync.addGroup('newGroup');\n            expect(formGroupAsync.groups).toEqual(jasmine.arrayContaining(['personal', 'address', 'newGroup']));\n          });\n\n          it('SHOULD throw an error if not string', () => {\n            expect(formGroupAsync.addGroup.bind(formGroupAsync, ['newGroup'])).toThrowAnyError();\n          });\n        });\n\n        describe('removeGroup', () => {\n          it('SHOULD set formGroups promises', () => {\n            expect(formGroupAsync.groups).toEqual(jasmine.arrayContaining(['personal', 'address']));\n            formGroupAsync.removeGroup('personal');\n            expect(formGroupAsync.groups).not.toEqual(jasmine.arrayContaining(['personal']));\n          });\n\n          it('SHOULD throw an error if not string', () => {\n            expect(formGroupAsync.removeGroup.bind(formGroupAsync, ['newGroup'])).toThrowAnyError();\n          });\n\n          it('SHOULD throw an error if not string', () => {\n            expect(formGroupAsync.removeGroup.bind(formGroupAsync, 'newGroup')).toThrowAnyError();\n            expect(formGroupAsync.removeGroup.bind(formGroupAsync, 'personal')).not.toThrowAnyError();\n            expect(formGroupAsync.removeGroup.bind(formGroupAsync, 'newGroup', true)).not.toThrowAnyError();\n          });\n        });\n\n        describe('then - success callback method', () => {\n          describe('single call back only', () => {\n            it('SHOULD call the last then method only', (done) => {\n              const mockPersonalDetails = { firstName: 'John' };\n              const mockDeliveryDetails = { line1: '123 Downing St.' };\n              const resolvedAsync = new FormGroupAsync({\n                formName: 'addressForm',\n                groups: ['personal', 'address']\n              });\n\n              resolvedAsync.resolve(\n                mockPersonalDetails,\n                resolvedAsync.getName(mockForm.groups[0])\n              );\n              resolvedAsync.resolve(\n                mockDeliveryDetails,\n                resolvedAsync.getName(mockForm.groups[1])\n              );\n\n              resolvedAsync.then((formData) => {\n                expect(formData.line1).toBe('THIS SHOULD NOT BE EXECUTED');\n                done();\n              }, true).then((formData) => {\n                expect(formData.firstName).toBe(mockPersonalDetails.firstName);\n                expect(formData.line1).toBe(mockDeliveryDetails.line1);\n                done();\n              }, true).fail(err => done.fail(`Error handler is called WHEN not intended | ${err}`));\n            });\n          });\n        });\n      });\n\n      describe('fail - error callback method', () => {\n        describe('single call back only', () => {\n          it('SHOULD call the last fail method only', (done) => {\n            const rejectedAsync = new FormGroupAsync({\n              formName: 'addressForm',\n              groups: ['personal', 'address']\n            });\n            const groupName = rejectedAsync.getName(mockForm.groups[0]);\n\n            rejectedAsync.reject(\n              ['error message'],\n              groupName\n            );\n\n            rejectedAsync.fail((err) => {\n              expect(err).toBe('THIS SHOULD NOT BE EXECUTED');\n              done();\n            }).fail((err) => {\n              expect(err).toBeArrayOfStrings();\n              expect(rejectedAsync.resolvedMemo[groupName]).toBeNull();\n              done();\n            }, true);\n          });\n        });\n      });\n\n      describe('Handling promises', () => {\n        it('SHOULD create an empty array to contain success/fail callback methods', () => {\n          const resolvedAsync = new FormGroupAsync({\n            formName: 'addressForm',\n            groups: ['personal', 'address']\n          });\n\n          expect(resolvedAsync.successCallbacks).toBeEmptyArray();\n          expect(resolvedAsync.failCallbacks).toBeEmptyArray();\n        });\n\n        describe('WHEN a group is resolved', () => {\n          it('SHOULD store the resolved data in a memo', () => {\n            const mockPersonalDetails = { firstName: 'John' };\n            const resolvedAsync = new FormGroupAsync({\n              formName: 'addressForm',\n              groups: ['personal', 'address']\n            });\n            const groupName = resolvedAsync.getName(mockForm.groups[0]);\n\n            resolvedAsync.resolve(\n              mockPersonalDetails,\n              groupName\n            );\n\n            expect(resolvedAsync.resolvedMemo[groupName]).toBeObject();\n          });\n\n          describe('AND resolved again', () => {\n            it('SHOULD store the latest resolved data in the memo', () => {\n              const resolvedAsync = new FormGroupAsync({\n                formName: 'addressForm',\n                groups: ['personal', 'address']\n              });\n              const groupName = resolvedAsync.getName(mockForm.groups[0]);\n\n              // since we cannot call the done method after a private promise is resolved\n              // assume the promise is resolved\n              resolvedAsync.resolvers[groupName] = undefined;\n              resolvedAsync.resolve(\n                { firstName: 'Ben' },\n                groupName\n              );\n              expect(resolvedAsync.resolvedMemo[groupName].firstName).toBe('Ben');\n            });\n          });\n\n          describe('AND rejected', () => {\n            it('SHOULD remove the resolved data from the memo', () => {\n              const resolvedAsync = new FormGroupAsync({\n                formName: 'addressForm',\n                groups: ['personal', 'address']\n              });\n              const groupName = resolvedAsync.getName(mockForm.groups[0]);\n\n              // since we cannot call the done method after a private promise is resolved\n              // assume the promise is resolved\n              resolvedAsync.rejecters[groupName] = undefined;\n              resolvedAsync.reject(\n                ['error msg'],\n                groupName\n              );\n              expect(resolvedAsync.resolvedMemo[groupName]).toBeNull();\n            });\n          });\n\n          describe('AND all groups are resolved', () => {\n            it('SHOULD call success method with correct data', (done) => {\n              const mockPersonalDetails = { firstName: 'John' };\n              const mockDeliveryDetails = { line1: '123 Downing St.' };\n              const resolvedAsync = new FormGroupAsync({\n                formName: 'addressForm',\n                groups: ['personal', 'address']\n              });\n\n              resolvedAsync.resolve(\n                mockPersonalDetails,\n                resolvedAsync.getName(mockForm.groups[0])\n              );\n              resolvedAsync.resolve(\n                mockDeliveryDetails,\n                resolvedAsync.getName(mockForm.groups[1])\n              );\n\n              resolvedAsync.then((formData) => {\n                expect(formData.firstName).toBe(mockPersonalDetails.firstName);\n                expect(formData.line1).toBe(mockDeliveryDetails.line1);\n                done();\n              }).fail(err => done.fail(`Error handler is called WHEN not intended | ${err}`));\n            });\n          });\n\n          describe('AND another group is rejected', () => {\n            let resolvedAsync;\n            let resolvedGroup;\n            beforeEach(() => {\n              const mockPersonalDetails = { firstName: 'John' };\n              resolvedAsync = new FormGroupAsync({\n                formName: 'addressForm',\n                groups: ['personal', 'address']\n              });\n              const groupName = resolvedAsync.getName(mockForm.groups[1]);\n              resolvedAsync.rejecters[groupName] = () => null;\n\n              resolvedGroup = resolvedAsync.getName(mockForm.groups[0]);\n              resolvedAsync.resolve(\n                mockPersonalDetails,\n                resolvedGroup\n              );\n              resolvedAsync.reject(\n                ['error msg'],\n                resolvedAsync.getName(mockForm.groups[1])\n              ).fail(() => null);\n            });\n\n            it('SHOULD remember the resolved promise', () => {\n            // since we cannot call the done method after catch\n            // assume the above beforeEach happened and the last THEN statement\n            // is executed\n              resolvedAsync.generatePromises();\n\n              expect(resolvedAsync.resolvedMemo[resolvedGroup]).toHaveMember('firstName');\n            });\n          });\n        });\n\n        describe('WHEN a group is rejected', () => {\n          it('SHOULD remove the group from the resolved memo', (done) => {\n            const rejectedAsync = new FormGroupAsync({\n              formName: 'addressForm',\n              groups: ['personal', 'address']\n            });\n            const groupName = rejectedAsync.getName(mockForm.groups[0]);\n\n            rejectedAsync.reject(\n              ['error message'],\n              groupName\n            );\n\n            rejectedAsync.fail((err) => {\n              expect(err).toBeArrayOfStrings();\n              expect(rejectedAsync.resolvedMemo[groupName]).toBeNull();\n              done();\n            });\n          });\n\n          it('SHOULD call error method', (done) => {\n            const rejectedAsync = new FormGroupAsync({\n              formName: 'addressForm',\n              groups: ['personal', 'address']\n            });\n\n            rejectedAsync.reject(\n              ['error message'],\n              rejectedAsync.getName(mockForm.groups[0])\n            );\n\n            rejectedAsync\n              .then(() => {\n                done.fail('Success handler is called WHEN not intended!');\n              })\n              .fail((err) => {\n                expect(err).toBeArrayOfStrings();\n                done();\n              });\n          });\n        });\n      });\n    }\n  );\n});\n"]}