{"version":3,"sources":["../../src/forms/formGroupAsyncSpec.js"],"names":["describe","mockForm","beforeEach","formName","groups","formGroupAsync","it","expect","toBe","toBeArrayOfStrings","resolve","toBeFunction","reject","getName","getNames","resolvers","toHaveMember","rejecters","resolvedMemo","toBeEmptyObject","bind","toThrowError","spyObj","fn","n","spyOn","each","toHaveBeenCalled","done","mockPersonalDetails","firstName","mockDeliveryDetails","line1","resolvedAsync","then","formData","fail","err","rejectedAsync","groupName","toBeNull","successCallbacks","toBeEmptyArray","failCallbacks","toBeObject","undefined","resolvedGroup","generatePromises"],"mappings":"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","file":"formGroupAsyncSpec.js","sourcesContent":["import FormGroupAsync from './formGroupAsync';\n\ndescribe('FormGroupAsync', () => {\n  describe(\n    `Use this if you have multiple form groups\n    AND you want to submit the form only WHEN all groups are valid`\n    , () => {\n      let mockForm;\n      beforeEach(() => {\n        mockForm = {\n          formName: 'addressForm',\n          groups: ['personal', 'address']\n        };\n      });\n\n      let formGroupAsync;\n      beforeEach(() => {\n        formGroupAsync = new FormGroupAsync(mockForm);\n      });\n\n      describe('initialise', () => {\n        it('SHOULD assign init props correctly', () => {\n          expect(formGroupAsync.formName).toBe(mockForm.formName);\n          expect(formGroupAsync.groups).toBeArrayOfStrings();\n        });\n\n        it(`SHOULD init all the necessary public methods\n        (resolve, reject, getName, getNames, each, success, fail)\n        `, () => {\n            expect(formGroupAsync.resolve).toBeFunction();\n            expect(formGroupAsync.reject).toBeFunction();\n            expect(formGroupAsync.getName).toBeFunction();\n            expect(formGroupAsync.getNames).toBeFunction();\n          });\n\n        it('SHOULD generate all the resolve callbacks with the correct names', () => {\n          expect(formGroupAsync.resolvers)\n            .toHaveMember(`${mockForm.formName}-${mockForm.groups[0]}`);\n          expect(formGroupAsync.resolvers)\n            .toHaveMember(`${mockForm.formName}-${mockForm.groups[1]}`);\n        });\n\n        it('SHOULD generate all the reject callbacks with the correct names', () => {\n          expect(formGroupAsync.rejecters)\n            .toHaveMember(`${mockForm.formName}-${mockForm.groups[0]}`);\n          expect(formGroupAsync.rejecters)\n            .toHaveMember(`${mockForm.formName}-${mockForm.groups[1]}`);\n        });\n\n        it('SHOULD generate a memo for resolved promises', () => {\n          expect(formGroupAsync.resolvedMemo).toBeEmptyObject();\n        });\n      });\n\n      describe('Utility methods', () => {\n        describe('getName - returns the name-spaced group name', () => {\n          it('SHOULD return the \"form name\" + \"group name\" as a concatenated string', () => {\n            expect(formGroupAsync.getName(mockForm.groups[0]))\n              .toBe(`${mockForm.formName}-${mockForm.groups[0]}`);\n          });\n\n          it('SHOULD throw an error if group name is not found', () => {\n            expect(formGroupAsync.getName.bind(formGroupAsync, 'dummyGroup')).toThrowError();\n          });\n        });\n\n        describe('getNames - returns an array of name-spaced group names', () => {\n          it('SHOULD return an array of group name (\"form name\" + \"group name\")', () => {\n            expect(formGroupAsync.getNames()).toBeArrayOfStrings();\n          });\n        });\n\n        describe('each - iterates through each group and executes the given callback method', () => {\n          it('SHOULD execute the given callback method', () => {\n            const spyObj = { fn: n => n };\n            spyOn(spyObj, 'fn');\n            formGroupAsync.each(spyObj.fn);\n            expect(spyObj.fn).toHaveBeenCalled();\n          });\n        });\n\n        describe('then - success callback method', () => {\n          describe('single call back only', () => {\n            it('SHOULD call the last then method only', (done) => {\n              const mockPersonalDetails = { firstName: 'John' };\n              const mockDeliveryDetails = { line1: '123 Downing St.' };\n              const resolvedAsync = new FormGroupAsync({\n                formName: 'addressForm',\n                groups: ['personal', 'address']\n              });\n\n              resolvedAsync.resolve(\n                mockPersonalDetails,\n                resolvedAsync.getName(mockForm.groups[0])\n              );\n              resolvedAsync.resolve(\n                mockDeliveryDetails,\n                resolvedAsync.getName(mockForm.groups[1])\n              );\n\n              resolvedAsync.then((formData) => {\n                expect(formData.line1).toBe('THIS SHOULD NOT BE EXECUTED');\n                done();\n              }, true).then((formData) => {\n                expect(formData.firstName).toBe(mockPersonalDetails.firstName);\n                expect(formData.line1).toBe(mockDeliveryDetails.line1);\n                done();\n              }, true).fail(err => done.fail(`Error handler is called WHEN not intended | ${err}`));\n            });\n          });\n        });\n      });\n\n      describe('fail - error callback method', () => {\n        describe('single call back only', () => {\n          it('SHOULD call the last fail method only', (done) => {\n            const rejectedAsync = new FormGroupAsync({\n              formName: 'addressForm',\n              groups: ['personal', 'address']\n            });\n            const groupName = rejectedAsync.getName(mockForm.groups[0]);\n\n            rejectedAsync.reject(\n              ['error message'],\n              groupName\n            );\n\n            rejectedAsync.fail((err) => {\n              expect(err).toBe('THIS SHOULD NOT BE EXECUTED');\n              done();\n            }).fail((err) => {\n              expect(err).toBeArrayOfStrings();\n              expect(rejectedAsync.resolvedMemo[groupName]).toBeNull();\n              done();\n            }, true);\n          });\n        });\n      });\n\n      describe('Handling promises', () => {\n        it('SHOULD create an empty array to contain success/fail callback methods', () => {\n          const resolvedAsync = new FormGroupAsync({\n            formName: 'addressForm',\n            groups: ['personal', 'address']\n          });\n\n          expect(resolvedAsync.successCallbacks).toBeEmptyArray();\n          expect(resolvedAsync.failCallbacks).toBeEmptyArray();\n        });\n\n        describe('WHEN a group is resolved', () => {\n          it('SHOULD store the resolved data in a memo', () => {\n            const mockPersonalDetails = { firstName: 'John' };\n            const resolvedAsync = new FormGroupAsync({\n              formName: 'addressForm',\n              groups: ['personal', 'address']\n            });\n            const groupName = resolvedAsync.getName(mockForm.groups[0]);\n\n            resolvedAsync.resolve(\n              mockPersonalDetails,\n              groupName\n            );\n\n            expect(resolvedAsync.resolvedMemo[groupName]).toBeObject();\n          });\n\n          describe('AND resolved again', () => {\n            it('SHOULD store the latest resolved data in the memo', () => {\n              const resolvedAsync = new FormGroupAsync({\n                formName: 'addressForm',\n                groups: ['personal', 'address']\n              });\n              const groupName = resolvedAsync.getName(mockForm.groups[0]);\n\n              // since we cannot call the done method after a private promise is resolved\n              // assume the promise is resolved\n              resolvedAsync.resolvers[groupName] = undefined;\n              resolvedAsync.resolve(\n                { firstName: 'Ben' },\n                groupName\n              );\n              expect(resolvedAsync.resolvedMemo[groupName].firstName).toBe('Ben');\n            });\n          });\n\n          describe('AND rejected', () => {\n            it('SHOULD remove the resolved data from the memo', () => {\n              const resolvedAsync = new FormGroupAsync({\n                formName: 'addressForm',\n                groups: ['personal', 'address']\n              });\n              const groupName = resolvedAsync.getName(mockForm.groups[0]);\n\n              // since we cannot call the done method after a private promise is resolved\n              // assume the promise is resolved\n              resolvedAsync.rejecters[groupName] = undefined;\n              resolvedAsync.reject(\n                ['error msg'],\n                groupName\n              );\n              expect(resolvedAsync.resolvedMemo[groupName]).toBeNull();\n            });\n          });\n\n          describe('AND all groups are resolved', () => {\n            it('SHOULD call success method with correct data', (done) => {\n              const mockPersonalDetails = { firstName: 'John' };\n              const mockDeliveryDetails = { line1: '123 Downing St.' };\n              const resolvedAsync = new FormGroupAsync({\n                formName: 'addressForm',\n                groups: ['personal', 'address']\n              });\n\n              resolvedAsync.resolve(\n                mockPersonalDetails,\n                resolvedAsync.getName(mockForm.groups[0])\n              );\n              resolvedAsync.resolve(\n                mockDeliveryDetails,\n                resolvedAsync.getName(mockForm.groups[1])\n              );\n\n              resolvedAsync.then((formData) => {\n                expect(formData.firstName).toBe(mockPersonalDetails.firstName);\n                expect(formData.line1).toBe(mockDeliveryDetails.line1);\n                done();\n              }).fail(err => done.fail(`Error handler is called WHEN not intended | ${err}`));\n            });\n          });\n\n          describe('AND another group is rejected', () => {\n            let resolvedAsync;\n            let resolvedGroup;\n            beforeEach(() => {\n              const mockPersonalDetails = { firstName: 'John' };\n              resolvedAsync = new FormGroupAsync({\n                formName: 'addressForm',\n                groups: ['personal', 'address']\n              });\n              const groupName = resolvedAsync.getName(mockForm.groups[1]);\n              resolvedAsync.rejecters[groupName] = () => null;\n\n              resolvedGroup = resolvedAsync.getName(mockForm.groups[0]);\n              resolvedAsync.resolve(\n                mockPersonalDetails,\n                resolvedGroup\n              );\n              resolvedAsync.reject(\n                ['error msg'],\n                resolvedAsync.getName(mockForm.groups[1])\n              ).fail(() => null);\n            });\n\n            it('SHOULD remember the resolved promise', () => {\n            // since we cannot call the done method after catch\n            // assume the above beforeEach happened and the last THEN statement\n            // is executed\n              resolvedAsync.generatePromises();\n\n              expect(resolvedAsync.resolvedMemo[resolvedGroup]).toHaveMember('firstName');\n            });\n          });\n        });\n\n        describe('WHEN a group is rejected', () => {\n          it('SHOULD remove the group from the resolved memo', (done) => {\n            const rejectedAsync = new FormGroupAsync({\n              formName: 'addressForm',\n              groups: ['personal', 'address']\n            });\n            const groupName = rejectedAsync.getName(mockForm.groups[0]);\n\n            rejectedAsync.reject(\n              ['error message'],\n              groupName\n            );\n\n            rejectedAsync.fail((err) => {\n              expect(err).toBeArrayOfStrings();\n              expect(rejectedAsync.resolvedMemo[groupName]).toBeNull();\n              done();\n            });\n          });\n\n          it('SHOULD call error method', (done) => {\n            const rejectedAsync = new FormGroupAsync({\n              formName: 'addressForm',\n              groups: ['personal', 'address']\n            });\n\n            rejectedAsync.reject(\n              ['error message'],\n              rejectedAsync.getName(mockForm.groups[0])\n            );\n\n            rejectedAsync\n              .then(() => {\n                done.fail('Success handler is called WHEN not intended!');\n              })\n              .fail((err) => {\n                expect(err).toBeArrayOfStrings();\n                done();\n              });\n          });\n        });\n      });\n    }\n  );\n});\n"]}