{"version":3,"sources":["../../src/validators/validatorSpec.js"],"names":["describe","formValidator","rulesAndMessageMock","constraints","beforeEach","rules","required","minlength","messages","it","expect","hasOwnProperty","toBe","reqMsg","message","toContain","setConstraints","toBeUndefined","formDataValid","formDataInvalid","errorMessages","validate","errorMessagesWithConstraints","toBeEmptyString","toBeDefined","toBeNonEmptyObject","toHaveArrayOfStrings","customConstraint","single","toBeNonEmptyArray","toBeArrayOfStrings"],"mappings":"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","file":"validatorSpec.js","sourcesContent":["import Validator from './validator';\n\n/*\n  TODO: still need to create adapters for 'async' validation\n  This use case is to check whether an email is already registered\n*/\n\ndescribe('Validator', () => {\n  describe(\n    `An adapter which transforms the backend validation rules and message\n     to the validate.js contraints format`\n  , () => {\n    let formValidator;\n    let rulesAndMessageMock;\n    let constraints;\n\n    beforeEach(() => {\n      rulesAndMessageMock = {\n        rules: {\n          'gx-number': {\n            required: true\n          },\n          'gx-pin': {\n            required: true,\n            minlength: 4\n          }\n        },\n        messages: {\n          'gx-number': {\n            required() {\n              return 'Please enter a valid giftcard number';\n            }\n          },\n          'gx-pin': {\n            required: 'Please enter a valid giftcard pin',\n            minlength: 'It has to be 4 characters long'\n          }\n        }\n      };\n    });\n\n    describe('Constructor', () => {\n      describe('Receives a rules and message JSON object and stores it for internal reuse', () => {\n        beforeEach(() => {\n          formValidator = new Validator(rulesAndMessageMock);\n          constraints = formValidator.constraints;\n        });\n\n        it('SHOULD adapt JSON rules and message to a compatible validator.js constraints', () => {\n          expect(constraints.hasOwnProperty('gx-number')).toBe(true);\n          expect(constraints.hasOwnProperty('gx-pin')).toBe(true);\n          expect(constraints['gx-number'].hasOwnProperty('required')).toBe(true);\n          expect(constraints['gx-number'].required.hasOwnProperty('message')).toBe(true);\n\n          const reqMsg = rulesAndMessageMock.messages['gx-pin'].required;\n          expect(constraints['gx-pin'].required.message).toContain(reqMsg);\n        });\n      });\n    });\n\n    describe('setConstraints', () => {\n      beforeEach(() => {\n        formValidator = new Validator(rulesAndMessageMock);\n        formValidator.setConstraints({\n          rules: {\n            'gx-number': {\n              required: true\n            }\n          },\n          messages: {\n            'gx-number': {\n              required: 'Please enter a valid giftcard number'\n            }\n          }\n        });\n        constraints = formValidator.constraints;\n      });\n\n      it('SHOULD replace the old constraint with the given constraints', () => {\n        expect(constraints['gx-pin']).toBeUndefined();\n      });\n    });\n\n    describe('validate', () => {\n      describe('call this function to validate a set of values', () => {\n        let formDataValid;\n        let formDataInvalid;\n\n        beforeEach(() => {\n          formDataValid = {\n            'gx-number': '123456789',\n            'gx-pin': '1234'\n          };\n        });\n\n        beforeEach(() => {\n          formDataInvalid = {\n            'gx-number': '',\n            'gx-pin': ''\n          };\n        });\n\n        it('SHOULD return empty string messages when data is valid', () => {\n          const errorMessages = formValidator.validate(formDataValid);\n          const errorMessagesWithConstraints = formValidator.validate(formDataValid, constraints);\n          expect(errorMessages).toBeEmptyString();\n          expect(errorMessagesWithConstraints).toBeEmptyString();\n        });\n\n        it('SHOULD return error messages when data is invalid', () => {\n          const errorMessages = formValidator.validate(formDataInvalid);\n          const errorMessagesWithConstraints = formValidator.validate(formDataInvalid, constraints);\n\n          expect(errorMessages).toBeDefined();\n          expect(errorMessages).toBeNonEmptyObject();\n          expect(errorMessages).toHaveArrayOfStrings('gx-number');\n\n          expect(errorMessagesWithConstraints).toBeDefined();\n          expect(errorMessagesWithConstraints).toBeNonEmptyObject();\n          expect(errorMessagesWithConstraints).toHaveArrayOfStrings('gx-number');\n        });\n      });\n    });\n\n    describe('single', () => {\n      describe('call this function to validate a single value', () => {\n        let customConstraint;\n\n        beforeEach(() => {\n          customConstraint = {\n            'gx-number': {\n              minlength: {\n                minlength: 10,\n                message: '^wrong'\n              }\n            }\n          };\n        });\n\n        it('SHOULD return empty string messages when data is valid', () => {\n          const errorMessages = formValidator.single('gx-number', {\n            'gx-number': 'value'\n          });\n          expect(errorMessages).toBeEmptyString();\n        });\n\n        it('SHOULD return error messages when data is invalid', () => {\n          const errorMessages = formValidator.single('gx-number', {\n            'gx-number': null\n          });\n          expect(errorMessages).toBeDefined();\n          expect(errorMessages).toBeNonEmptyArray();\n          expect(errorMessages).toBeArrayOfStrings('gx-number');\n        });\n\n        it('SHOULD use passed custom constraints', () => {\n          const errorMessages = formValidator.single('gx-number', {\n            'gx-number': 'value'\n          }, customConstraint);\n          expect(errorMessages).toBeDefined();\n          expect(errorMessages).toBeNonEmptyArray();\n          expect(errorMessages).toBeArrayOfStrings('gx-number');\n          expect(errorMessages).toContain('wrong');\n        });\n      });\n    });\n  });\n});\n"]}